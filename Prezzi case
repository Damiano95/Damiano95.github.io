---
title: "Prezzi case"
output: html_document
---

NAME: Damiano Casiraghi

BADGE: 790132

NICKNAME: d.casiraghi
TEAM: boxcox

ROUND: 1st


### References:

* Copy/paste from Kaggle's Kernel [House prices: Lasso, XGBoost, and a detailed EDA](https://www.kaggle.com/erikbruin/house-prices-lasso-xgboost-and-a-detailed-eda)

### Models

* Lasso
* Random Forest
* Xgboost

### Non-standard R packages

-

```{r startup, include = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = T, eval=T, message=F, warning=F, error=F, comment=NA, cache=F, R.options=list(width=220))
```


### R code to reproduce the last submission:

```{r}
library(ggplot2)
library(caret)
library(randomForest)

train <- read.csv("http://bee-fore.s3-eu-west-1.amazonaws.com/datasets/60.csv", stringsAsFactors=F)
test <- read.csv("http://bee-fore.s3-eu-west-1.amazonaws.com/datasets/61.csv", stringsAsFactors=F)

test[,82]=NA
names(test)[82]=names(train)[82]
train$SalePrice=log(train$SalePrice)
fulldata=rbind(train,test)


#ricodifico le variabili dell'intero dataset, poi li divider?.
#innanzitutto devo ricodificare le variabili ordinali, dalla descrizione delle variabili 
#ho che molti NA portano delle informazioni (es assenza di piscina)

#NA variabili nominali:
# Alley
# Garage.Type
# Misc.Feature

Na_char=c("Alley","Garage.Type","Misc.Feature")
pos_char=which(names(fulldata) %in% Na_char)
prova=sapply(fulldata[,pos_char], is.na)
fulldata[,pos_char][prova]="None"


#factors
# Bsmt.Qual
# Bsmt.Cond
# Bsmt.Exposure
# Bsmt.Fin.Type.1
# Bsmt.Fin.Type.2
# Fireplace.Qu
# Garage.Finish
# Garage.Qual
# Garage.Cond
# Pool.QC
# Fence

NA_fac=c("Bsmt.Qual",
         "Bsmt.Cond",
         "Bsmt.Exposure",
         "BsmtFin.Type.1",
         "BsmtFin.Type.2",
         "Fireplace.Qu",
         "Garage.Finish",
         "Garage.Qual",
         "Garage.Cond",
         "Pool.QC",
         "Fence")

pos_fac=which(names(fulldata) %in% NA_fac)
prova=sapply(fulldata[,pos_fac], is.na)
fulldata[,pos_fac][prova]="None"

#adesso non resta che trasformare le variabili factor:
# Lot.Shape
# Utilities
# Land.Slope
# Overall.Qual
# Overall.Cond
# Exter.Qual
# Exter.Cond
# Heating.QC
# Electrical
# Kitchen.Qual
# Functional
# Paved.Drive

fac2=c("Lot.Shape",
           "Utilities",
           "Land.Slope",
           "Overall.Qual",
           "Overall.Cond",
           "Exter.Qual",
           "Exter.Cond",
           "Heating.QC",
           "Electrical",
           "Kitchen.Qual",
           "Functional",
           "Paved.Drive",
           "Neighborhood")

pos_fac2=which(names(fulldata) %in% fac2)
fac_fin=sort(c(pos_fac,pos_fac2))
fulldata[,fac_fin]=lapply(fulldata[,fac_fin],as.factor)

data.frame.fulldata=as.data.frame(fulldata)

#rimangono ancora NA da sistemare: iniziamo con Lot.Frontage
#non avendo informazioni sostituisco il valore mancante con la media 
#condizionata a "Neighborhood"

medie_cond=aggregate(data.frame.fulldata$Lot.Frontage, by=list(data.frame.fulldata$Neighborhood), na.rm=T, FUN=mean)
rownames(medie_cond)=medie_cond[,1]

NA_lot=which(is.na(fulldata$Lot.Frontage))
for(i in 1:nrow(fulldata)){
  if (is.na(fulldata$Lot.Frontage[i])==T) {
    area=fulldata$Neighborhood[i]
    fulldata$Lot.Frontage[i]=medie_cond[area,2]
  }
}

#rimangono ancora 3 case con NA, e gli assegnerò il valore medio generale
NA_lot=which(is.na(fulldata$Lot.Frontage))
fulldata$Lot.Frontage[NA_lot]= mean(fulldata$Lot.Frontage, na.rm = T)

#per quanto riguarda la data di costruzione del garage posso approssimarla con la data di costruzione dell'edificio, quindi
NA_gar=which(is.na(fulldata$Garage.Yr.Blt))
fulldata$Garage.Yr.Blt[NA_gar]=fulldata$Year.Built[NA_gar]

#dopo aver guardato gli NA rimasti attraverso la funziona aggr del pacchetto "VIM" ho deciso di sostituire i 
#valori mancanti rimasti con la moda

#Mas.Vnr.Area
NA_Mas=which(is.na(fulldata$Mas.Vnr.Area))
fulldata$Mas.Vnr.Area[NA_Mas]=0

#Bsmt.Full.Bath
NA_full.bath=which(is.na(fulldata$Bsmt.Full.Bath))
fulldata$Bsmt.Full.Bath[NA_full.bath]=0

#Bsmt.Half.Bath
NA_half.bath=which(is.na(fulldata$Bsmt.Half.Bath))
fulldata$Bsmt.Half.Bath[NA_half.bath]=0

#BsmtFin.SF.1
NA_bsmtfin=which(is.na(fulldata$BsmtFin.SF.1))
fulldata$BsmtFin.SF.1[NA_bsmtfin]=0

#BsmtFin.SF.2
NA_bsmtfin2=which(is.na(fulldata$BsmtFin.SF.2))
fulldata$BsmtFin.SF.2[NA_bsmtfin2]=0

#Bsmt.Unf.SF 
NA_bsmtunf=which(is.na(fulldata$Bsmt.Unf.SF ))
fulldata$Bsmt.Unf.SF [NA_bsmtunf]=0

#Total.Bsmt.SF   
NA_totbsmt=which(is.na(fulldata$Total.Bsmt.SF  ))
fulldata$Total.Bsmt.SF[NA_totbsmt]=0

#Garage.Cars   
NA_garcars=which(is.na(fulldata$Garage.Cars))
fulldata$Garage.Cars[NA_garcars]=2

#Garage.Area 
NA_gararea=which(is.na(fulldata$Garage.Area))
fulldata$Garage.Area[NA_gararea]=0

#prima di spezzare i dataset creo una variabile che invcluda il numero totale di bagni presenti in una casa
fulldata$Tot.Bathrooms=fulldata$Full.Bath + fulldata$Half.Bath + fulldata$Bsmt.Full.Bath + fulldata$Bsmt.Half.Bath

#per evitare casini
char=which(sapply(fulldata,is.character))
pos_char=which(names(fulldata) %in% names(char))
fulldata[,pos_char]=lapply(fulldata[,pos_char], as.factor)

oss_test=which(is.na(fulldata$SalePrice)==T)

train2=fulldata[-oss_test,]
test2=fulldata[oss_test,]

#ho molte variabili riferite a stessi argomenti (ad esempio bagni), quindi vado a vedere "per argomento" quali sono le 
#più importanti, in modo da evitare problemi di collinearità e vedere se c'è qualcosa che posso fare 

#garage:
# Garage.Type
# Garage.Yr.Blt   
# Garage.Finish   
# Garage.Cars    
# Garage.Area
# Garage.Qual
# Garage.Cond

library(glmnet)
pos_garage=which(names(train2)=="Garage.Type" | 
                 names(train2)=="Garage.Yr.Blt" | 
                 names(train2)== "Garage.Finish" |   
                 names(train2)=="Garage.Cars"  |  
                 names(train2)=="Garage.Area" |
                 names(train2)=="Garage.Qual"|
                 names(train2)=="Garage.Cond")

ctrl <- trainControl(method = "cv",
                     number = 10)

set.seed(987)
lasso_garage <- train(SalePrice ~ ., 
            train2[,c(pos_garage,82)],
            method = "glmnet",
            tuneGrid=expand.grid(alpha=1, lambda=seq(0.001,1, by=0.001)),
            trControl=ctrl, 
            ## Specify which metric to optimize
            metric = "RMSE")


best_garage=which(names(train2)=="Garage.Type" | 
                    names(train2)=="Garage.Cond")
garage_rm=setdiff(pos_garage,best_garage)

#Le variabili più importanti sono Garage.Cond e Garage.Type

#proviamo le variabili del Basement:
# Bsmt.Qual
# Bsmt.Cond
# Bsmt.Exposure
# Bsmt.Fin.Type.1
# Bsmt.Fin.SF.1
# Bsmt.Fin.Type.2
# Bsmt.Fin.SF.2
# Bsmt.Unf.SF
names(train2)
pos_Bsmt=which(names(train2)=="Bsmt.Qual" | 
                   names(train2)=="Bsmt.Cond" | 
                   names(train2)=="Bsmt.Exposure" |   
                   names(train2)=="BsmtFin.Type.1"  |  
                   names(train2)=="BsmtFin.SF.1"|
                   names(train2)=="BsmtFin.Type.2"|
                   names(train2)=="BsmtFin.SF.2"|
                   names(train2)=="Bsmt.Unf.SF")

set.seed(987)
lasso_Bsmt <- train(SalePrice ~ ., 
               train2[,c(pos_Bsmt,82)],
               method = "glmnet",
               tuneGrid=expand.grid(alpha=1, lambda=seq(0.001,1, by=0.001)),
               trControl=ctrl, 
               ## Specify which metric to optimize
               metric = "RMSE")

best_Bsmt=which(names(train2)=="Bsmt.Qual" | 
                 names(train2)=="Bsmt.Cond" | 
                 names(train2)== "BsmtFin.Type.2")
Bsmt_rm=setdiff(pos_Bsmt, best_Bsmt)
#le più importanti sono: "Bsmt.Qual" "Bsmt.Cond" "BsmtFin.Type.2" 

#variabili del bagno
# Full.Bath 
# Half.Bath
# Bsmt.Full.Bath
# Bsmt.Half.Bath

pos_bath=which(names(train2)=="Full.Bath" | 
        names(train2)== "Half.Bath" |   
        names(train2)=="Bsmt.Full.Bath"  |  
        names(train2)=="Bsmt.Half.Bath")

set.seed(987)
lasso_bath <- train(SalePrice ~ ., 
                      train2[,c(pos_bath,82)],
                      method = "glmnet",
                      tuneGrid=expand.grid(alpha=1, lambda=seq(0.001,1, by=0.001)),
                      trControl=ctrl, 
                      ## Specify which metric to optimize
                      metric = "RMSE")

#provo a tenerle tutte

#provo ad eseguire una lasso e poi una rf


set.seed(987) #la random forest risulta migliore usando tutte le variabili
rf=randomForest(SalePrice ~ ., data=train2, ntree=1000, importance=T)


yhat_rf =exp(predict(rf, newdata=test2))

set.seed(789)
xgb <- train(SalePrice ~ ., 
              train2,
              method = "xgbTree",
              trControl=ctrl, 
              importance=T,
              ## Specify which metric to optimize
              metric = "RMSE")

yhat_xgb =exp(predict(xgb, newdata=test2))

#regressione ridge
set.seed(789) #risulta migliore usando quella completa
ridge <- train(SalePrice ~ ., 
               train2,
               method = "glmnet",
               tuneGrid=expand.grid(alpha=0, lambda=seq(0.001,1, by=0.001)),
               trControl=ctrl, 
               ## Specify which metric to optimize
               metric = "RMSE")
yhat_ridge =exp(predict(ridge, newdata=test2))
#combinazioni di modelli

ridge_rf_xgb=(yhat_ridge+yhat_rf+yhat_xgb)/3 #uso questo modello
head(ridge_rf_xgb)
```

